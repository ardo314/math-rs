// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod ardo314 {
        pub mod math {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                /// x, y
                pub type Vector2d = (f32, f32);
                /// x, y, z
                pub type Vector3d = (f32, f32, f32);
                /// x, y, z, w
                pub type Vector4d = (f32, f32, f32, f32);
                /// m[row column]
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Matrix2x2 {
                    pub m00: f32,
                    pub m10: f32,
                    pub m01: f32,
                    pub m11: f32,
                }
                impl ::core::fmt::Debug for Matrix2x2 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Matrix2x2")
                            .field("m00", &self.m00)
                            .field("m10", &self.m10)
                            .field("m01", &self.m01)
                            .field("m11", &self.m11)
                            .finish()
                    }
                }
                /// m[row column]
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Matrix3x3 {
                    pub m00: f32,
                    pub m10: f32,
                    pub m20: f32,
                    pub m01: f32,
                    pub m11: f32,
                    pub m21: f32,
                    pub m02: f32,
                    pub m12: f32,
                    pub m22: f32,
                }
                impl ::core::fmt::Debug for Matrix3x3 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Matrix3x3")
                            .field("m00", &self.m00)
                            .field("m10", &self.m10)
                            .field("m20", &self.m20)
                            .field("m01", &self.m01)
                            .field("m11", &self.m11)
                            .field("m21", &self.m21)
                            .field("m02", &self.m02)
                            .field("m12", &self.m12)
                            .field("m22", &self.m22)
                            .finish()
                    }
                }
                /// m[row column]
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Matrix4x4 {
                    pub m00: f32,
                    pub m10: f32,
                    pub m20: f32,
                    pub m30: f32,
                    pub m01: f32,
                    pub m11: f32,
                    pub m21: f32,
                    pub m31: f32,
                    pub m02: f32,
                    pub m12: f32,
                    pub m22: f32,
                    pub m32: f32,
                    pub m03: f32,
                    pub m13: f32,
                    pub m23: f32,
                    pub m33: f32,
                }
                impl ::core::fmt::Debug for Matrix4x4 {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Matrix4x4")
                            .field("m00", &self.m00)
                            .field("m10", &self.m10)
                            .field("m20", &self.m20)
                            .field("m30", &self.m30)
                            .field("m01", &self.m01)
                            .field("m11", &self.m11)
                            .field("m21", &self.m21)
                            .field("m31", &self.m31)
                            .field("m02", &self.m02)
                            .field("m12", &self.m12)
                            .field("m22", &self.m22)
                            .field("m32", &self.m32)
                            .field("m03", &self.m03)
                            .field("m13", &self.m13)
                            .field("m23", &self.m23)
                            .field("m33", &self.m33)
                            .finish()
                    }
                }
                /// axis with angle magnitude
                pub type RotationVector = (f32, f32, f32);
                /// axis, angle
                pub type AxisAngle = (Vector3d, f32);
                /// x, y, z, w
                pub type Quaternion = (f32, f32, f32, f32);
                /// x, y, theta
                pub type Pose2d = (f32, f32, f32);
                /// x, y, z, rx, ry, rz (axis with angle magnitude)
                pub type Pose3d = (f32, f32, f32, f32, f32, f32);
                /// x, y
                pub type Point2d = (f32, f32);
                /// x, y, z
                pub type Point3d = (f32, f32, f32);
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_types_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_types_0_0_3_cabi;
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vector2d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Vector2d = super::super::super::super::exports::ardo314::math::types::Vector2d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_dot_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::dot((arg0, arg1), (arg2, arg3));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_f32((arg0, arg1), arg2);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_f32((arg0, arg1), arg2);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_f32((arg0, arg1), arg2);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div_f32((arg0, arg1), arg2);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_neg_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::neg((arg0, arg1));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sqr_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sqr_length((arg0, arg1));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::length((arg0, arg1));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_normalize_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::normalize((arg0, arg1));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                pub trait Guest {
                    fn add(lhs: Vector2d, rhs: Vector2d) -> Vector2d;
                    fn sub(lhs: Vector2d, rhs: Vector2d) -> Vector2d;
                    fn dot(lhs: Vector2d, rhs: Vector2d) -> f32;
                    fn add_f32(lhs: Vector2d, rhs: f32) -> Vector2d;
                    fn sub_f32(lhs: Vector2d, rhs: f32) -> Vector2d;
                    fn mul_f32(lhs: Vector2d, rhs: f32) -> Vector2d;
                    fn div_f32(lhs: Vector2d, rhs: f32) -> Vector2d;
                    fn neg(v: Vector2d) -> Vector2d;
                    fn sqr_length(v: Vector2d) -> f32;
                    fn length(v: Vector2d) -> f32;
                    fn normalize(v: Vector2d) -> Vector2d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_vector2d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#add")] unsafe extern "C" fn
                        export_add(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) -> *
                        mut u8 { unsafe { $($path_to_types)*:: _export_add_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#sub")] unsafe extern "C" fn
                        export_sub(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) -> *
                        mut u8 { unsafe { $($path_to_types)*:: _export_sub_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#dot")] unsafe extern "C" fn
                        export_dot(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) ->
                        f32 { unsafe { $($path_to_types)*:: _export_dot_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#add-f32")] unsafe extern "C" fn
                        export_add_f32(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_add_f32_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#sub-f32")] unsafe extern "C" fn
                        export_sub_f32(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_sub_f32_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#mul-f32")] unsafe extern "C" fn
                        export_mul_f32(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_mul_f32_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#div-f32")] unsafe extern "C" fn
                        export_div_f32(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_div_f32_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#neg")] unsafe extern "C" fn
                        export_neg(arg0 : f32, arg1 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_neg_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#sqr-length")] unsafe extern "C" fn
                        export_sqr_length(arg0 : f32, arg1 : f32,) -> f32 { unsafe {
                        $($path_to_types)*:: _export_sqr_length_cabi::<$ty > (arg0, arg1)
                        } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.3#length")] unsafe extern "C" fn
                        export_length(arg0 : f32, arg1 : f32,) -> f32 { unsafe {
                        $($path_to_types)*:: _export_length_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name = "ardo314:math/vector2d@0.0.3#normalize")]
                        unsafe extern "C" fn export_normalize(arg0 : f32, arg1 : f32,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_normalize_cabi::<$ty > (arg0, arg1) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_vector2d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vector3d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Vector3d = super::super::super::super::exports::ardo314::math::types::Vector3d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add((arg0, arg1, arg2), (arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub((arg0, arg1, arg2), (arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_dot_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::dot((arg0, arg1, arg2), (arg3, arg4, arg5));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_f32((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_f32((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_f32((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div_f32((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_neg_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::neg((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sqr_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sqr_length((arg0, arg1, arg2));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::length((arg0, arg1, arg2));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_normalize_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::normalize((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_cross_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::cross((arg0, arg1, arg2), (arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                pub trait Guest {
                    fn add(lhs: Vector3d, rhs: Vector3d) -> Vector3d;
                    fn sub(lhs: Vector3d, rhs: Vector3d) -> Vector3d;
                    fn dot(lhs: Vector3d, rhs: Vector3d) -> f32;
                    fn add_f32(lhs: Vector3d, rhs: f32) -> Vector3d;
                    fn sub_f32(lhs: Vector3d, rhs: f32) -> Vector3d;
                    fn mul_f32(lhs: Vector3d, rhs: f32) -> Vector3d;
                    fn div_f32(lhs: Vector3d, rhs: f32) -> Vector3d;
                    fn neg(v: Vector3d) -> Vector3d;
                    fn sqr_length(v: Vector3d) -> f32;
                    fn length(v: Vector3d) -> f32;
                    fn normalize(v: Vector3d) -> Vector3d;
                    fn cross(lhs: Vector3d, rhs: Vector3d) -> Vector3d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_vector3d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.3#add")] unsafe extern "C" fn
                        export_add(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_add_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.3#sub")]
                        unsafe extern "C" fn export_sub(arg0 : f32, arg1 : f32, arg2 :
                        f32, arg3 : f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sub_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.3#dot")] unsafe extern "C" fn
                        export_dot(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32,) -> f32 { unsafe { $($path_to_types)*::
                        _export_dot_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.3#add-f32")]
                        unsafe extern "C" fn export_add_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_add_f32_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.3#sub-f32")]
                        unsafe extern "C" fn export_sub_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_sub_f32_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.3#mul-f32")]
                        unsafe extern "C" fn export_mul_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_f32_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.3#div-f32")]
                        unsafe extern "C" fn export_div_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_div_f32_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.3#neg")]
                        unsafe extern "C" fn export_neg(arg0 : f32, arg1 : f32, arg2 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_neg_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
                        (export_name = "ardo314:math/vector3d@0.0.3#sqr-length")] unsafe
                        extern "C" fn export_sqr_length(arg0 : f32, arg1 : f32, arg2 :
                        f32,) -> f32 { unsafe { $($path_to_types)*::
                        _export_sqr_length_cabi::<$ty > (arg0, arg1, arg2) } } #[unsafe
                        (export_name = "ardo314:math/vector3d@0.0.3#length")] unsafe
                        extern "C" fn export_length(arg0 : f32, arg1 : f32, arg2 : f32,)
                        -> f32 { unsafe { $($path_to_types)*:: _export_length_cabi::<$ty
                        > (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.3#normalize")] unsafe extern "C" fn
                        export_normalize(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_normalize_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.3#cross")] unsafe extern "C" fn
                        export_cross(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4
                        : f32, arg5 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_cross_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5) }
                        } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_vector3d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 12],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vector4d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Vector4d = super::super::super::super::exports::ardo314::math::types::Vector4d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                    arg6: f32,
                    arg7: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add(
                        (arg0, arg1, arg2, arg3),
                        (arg4, arg5, arg6, arg7),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                    arg6: f32,
                    arg7: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub(
                        (arg0, arg1, arg2, arg3),
                        (arg4, arg5, arg6, arg7),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_dot_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                    arg6: f32,
                    arg7: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::dot(
                        (arg0, arg1, arg2, arg3),
                        (arg4, arg5, arg6, arg7),
                    );
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_f32((arg0, arg1, arg2, arg3), arg4);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_f32((arg0, arg1, arg2, arg3), arg4);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_f32((arg0, arg1, arg2, arg3), arg4);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div_f32((arg0, arg1, arg2, arg3), arg4);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_neg_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::neg((arg0, arg1, arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sqr_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sqr_length((arg0, arg1, arg2, arg3));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::length((arg0, arg1, arg2, arg3));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_normalize_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::normalize((arg0, arg1, arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                pub trait Guest {
                    fn add(lhs: Vector4d, rhs: Vector4d) -> Vector4d;
                    fn sub(lhs: Vector4d, rhs: Vector4d) -> Vector4d;
                    fn dot(lhs: Vector4d, rhs: Vector4d) -> f32;
                    fn add_f32(lhs: Vector4d, rhs: f32) -> Vector4d;
                    fn sub_f32(lhs: Vector4d, rhs: f32) -> Vector4d;
                    fn mul_f32(lhs: Vector4d, rhs: f32) -> Vector4d;
                    fn div_f32(lhs: Vector4d, rhs: f32) -> Vector4d;
                    fn neg(v: Vector4d) -> Vector4d;
                    fn sqr_length(v: Vector4d) -> f32;
                    fn length(v: Vector4d) -> f32;
                    fn normalize(v: Vector4d) -> Vector4d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_vector4d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#add")] unsafe extern "C" fn
                        export_add(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32, arg6 : f32, arg7 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_add_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6, arg7) } } #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#sub")] unsafe extern "C" fn
                        export_sub(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32, arg6 : f32, arg7 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sub_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6, arg7) } } #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#dot")] unsafe extern "C" fn
                        export_dot(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32, arg6 : f32, arg7 : f32,) -> f32 { unsafe {
                        $($path_to_types)*:: _export_dot_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6, arg7) } } #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#add-f32")] unsafe extern "C" fn
                        export_add_f32(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,
                        arg4 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_add_f32_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4) } }
                        #[unsafe (export_name = "ardo314:math/vector4d@0.0.3#sub-f32")]
                        unsafe extern "C" fn export_sub_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32, arg4 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sub_f32_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4) } } #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#mul-f32")] unsafe extern "C" fn
                        export_mul_f32(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,
                        arg4 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_f32_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4) } }
                        #[unsafe (export_name = "ardo314:math/vector4d@0.0.3#div-f32")]
                        unsafe extern "C" fn export_div_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32, arg4 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_div_f32_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4) } } #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#neg")] unsafe extern "C" fn
                        export_neg(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) -> *
                        mut u8 { unsafe { $($path_to_types)*:: _export_neg_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector4d@0.0.3#sqr-length")] unsafe extern "C" fn
                        export_sqr_length(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> f32 { unsafe { $($path_to_types)*::
                        _export_sqr_length_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name = "ardo314:math/vector4d@0.0.3#length")]
                        unsafe extern "C" fn export_length(arg0 : f32, arg1 : f32, arg2 :
                        f32, arg3 : f32,) -> f32 { unsafe { $($path_to_types)*::
                        _export_length_cabi::<$ty > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name = "ardo314:math/vector4d@0.0.3#normalize")] unsafe
                        extern "C" fn export_normalize(arg0 : f32, arg1 : f32, arg2 :
                        f32, arg3 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_normalize_cabi::<$ty > (arg0, arg1, arg2, arg3) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_vector4d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 16],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod matrix2x2 {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Matrix2x2 = super::super::super::super::exports::ardo314::math::types::Matrix2x2;
                pub type Vector2d = super::super::super::super::exports::ardo314::math::types::Vector2d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_identity_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::identity();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix2x2 {
                        m00: m002,
                        m10: m102,
                        m01: m012,
                        m11: m112,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m112);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                    arg6: f32,
                    arg7: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul(
                        super::super::super::super::exports::ardo314::math::types::Matrix2x2 {
                            m00: arg0,
                            m10: arg1,
                            m01: arg2,
                            m11: arg3,
                        },
                        super::super::super::super::exports::ardo314::math::types::Matrix2x2 {
                            m00: arg4,
                            m10: arg5,
                            m01: arg6,
                            m11: arg7,
                        },
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix2x2 {
                        m00: m002,
                        m10: m102,
                        m01: m012,
                        m11: m112,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m112);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_vector2d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_vector2d(
                        super::super::super::super::exports::ardo314::math::types::Matrix2x2 {
                            m00: arg0,
                            m10: arg1,
                            m01: arg2,
                            m11: arg3,
                        },
                        (arg4, arg5),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                pub trait Guest {
                    fn identity() -> Matrix2x2;
                    fn mul(lhs: Matrix2x2, rhs: Matrix2x2) -> Matrix2x2;
                    fn mul_vector2d(lhs: Matrix2x2, rhs: Vector2d) -> Vector2d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_matrix2x2_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/matrix2x2@0.0.3#identity")] unsafe extern "C" fn
                        export_identity() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_identity_cabi::<$ty > () } } #[unsafe (export_name =
                        "ardo314:math/matrix2x2@0.0.3#mul")] unsafe extern "C" fn
                        export_mul(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32, arg6 : f32, arg7 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_mul_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6, arg7) } } #[unsafe (export_name =
                        "ardo314:math/matrix2x2@0.0.3#mul-vector2d")] unsafe extern "C"
                        fn export_mul_vector2d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_mul_vector2d_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_matrix2x2_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 16]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 16],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod matrix3x3 {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Matrix3x3 = super::super::super::super::exports::ardo314::math::types::Matrix3x3;
                pub type Vector3d = super::super::super::super::exports::ardo314::math::types::Vector3d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_identity_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::identity();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                        m00: m002,
                        m10: m102,
                        m20: m202,
                        m01: m012,
                        m11: m112,
                        m21: m212,
                        m02: m022,
                        m12: m122,
                        m22: m222,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m202);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(16).cast::<f32>() = _rt::as_f32(m112);
                    *ptr1.add(20).cast::<f32>() = _rt::as_f32(m212);
                    *ptr1.add(24).cast::<f32>() = _rt::as_f32(m022);
                    *ptr1.add(28).cast::<f32>() = _rt::as_f32(m122);
                    *ptr1.add(32).cast::<f32>() = _rt::as_f32(m222);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<f32>();
                    let l1 = *arg0.add(4).cast::<f32>();
                    let l2 = *arg0.add(8).cast::<f32>();
                    let l3 = *arg0.add(12).cast::<f32>();
                    let l4 = *arg0.add(16).cast::<f32>();
                    let l5 = *arg0.add(20).cast::<f32>();
                    let l6 = *arg0.add(24).cast::<f32>();
                    let l7 = *arg0.add(28).cast::<f32>();
                    let l8 = *arg0.add(32).cast::<f32>();
                    let l9 = *arg0.add(36).cast::<f32>();
                    let l10 = *arg0.add(40).cast::<f32>();
                    let l11 = *arg0.add(44).cast::<f32>();
                    let l12 = *arg0.add(48).cast::<f32>();
                    let l13 = *arg0.add(52).cast::<f32>();
                    let l14 = *arg0.add(56).cast::<f32>();
                    let l15 = *arg0.add(60).cast::<f32>();
                    let l16 = *arg0.add(64).cast::<f32>();
                    let l17 = *arg0.add(68).cast::<f32>();
                    let result18 = T::mul(
                        super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                            m00: l0,
                            m10: l1,
                            m20: l2,
                            m01: l3,
                            m11: l4,
                            m21: l5,
                            m02: l6,
                            m12: l7,
                            m22: l8,
                        },
                        super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                            m00: l9,
                            m10: l10,
                            m20: l11,
                            m01: l12,
                            m11: l13,
                            m21: l14,
                            m02: l15,
                            m12: l16,
                            m22: l17,
                        },
                    );
                    _rt::cabi_dealloc(arg0, 72, 4);
                    let ptr19 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                        m00: m0020,
                        m10: m1020,
                        m20: m2020,
                        m01: m0120,
                        m11: m1120,
                        m21: m2120,
                        m02: m0220,
                        m12: m1220,
                        m22: m2220,
                    } = result18;
                    *ptr19.add(0).cast::<f32>() = _rt::as_f32(m0020);
                    *ptr19.add(4).cast::<f32>() = _rt::as_f32(m1020);
                    *ptr19.add(8).cast::<f32>() = _rt::as_f32(m2020);
                    *ptr19.add(12).cast::<f32>() = _rt::as_f32(m0120);
                    *ptr19.add(16).cast::<f32>() = _rt::as_f32(m1120);
                    *ptr19.add(20).cast::<f32>() = _rt::as_f32(m2120);
                    *ptr19.add(24).cast::<f32>() = _rt::as_f32(m0220);
                    *ptr19.add(28).cast::<f32>() = _rt::as_f32(m1220);
                    *ptr19.add(32).cast::<f32>() = _rt::as_f32(m2220);
                    ptr19
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_vector3d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                    arg6: f32,
                    arg7: f32,
                    arg8: f32,
                    arg9: f32,
                    arg10: f32,
                    arg11: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_vector3d(
                        super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                            m00: arg0,
                            m10: arg1,
                            m20: arg2,
                            m01: arg3,
                            m11: arg4,
                            m21: arg5,
                            m02: arg6,
                            m12: arg7,
                            m22: arg8,
                        },
                        (arg9, arg10, arg11),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                pub trait Guest {
                    fn identity() -> Matrix3x3;
                    fn mul(lhs: Matrix3x3, rhs: Matrix3x3) -> Matrix3x3;
                    fn mul_vector3d(lhs: Matrix3x3, rhs: Vector3d) -> Vector3d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_matrix3x3_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/matrix3x3@0.0.3#identity")] unsafe extern "C" fn
                        export_identity() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_identity_cabi::<$ty > () } } #[unsafe (export_name =
                        "ardo314:math/matrix3x3@0.0.3#mul")] unsafe extern "C" fn
                        export_mul(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_mul_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name = "ardo314:math/matrix3x3@0.0.3#mul-vector3d")]
                        unsafe extern "C" fn export_mul_vector3d(arg0 : f32, arg1 : f32,
                        arg2 : f32, arg3 : f32, arg4 : f32, arg5 : f32, arg6 : f32, arg7
                        : f32, arg8 : f32, arg9 : f32, arg10 : f32, arg11 : f32,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_vector3d_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5, arg6, arg7, arg8, arg9, arg10, arg11) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_matrix3x3_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 36],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod matrix4x4 {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Matrix4x4 = super::super::super::super::exports::ardo314::math::types::Matrix4x4;
                pub type Vector4d = super::super::super::super::exports::ardo314::math::types::Vector4d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_identity_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::identity();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix4x4 {
                        m00: m002,
                        m10: m102,
                        m20: m202,
                        m30: m302,
                        m01: m012,
                        m11: m112,
                        m21: m212,
                        m31: m312,
                        m02: m022,
                        m12: m122,
                        m22: m222,
                        m32: m322,
                        m03: m032,
                        m13: m132,
                        m23: m232,
                        m33: m332,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m202);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m302);
                    *ptr1.add(16).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(20).cast::<f32>() = _rt::as_f32(m112);
                    *ptr1.add(24).cast::<f32>() = _rt::as_f32(m212);
                    *ptr1.add(28).cast::<f32>() = _rt::as_f32(m312);
                    *ptr1.add(32).cast::<f32>() = _rt::as_f32(m022);
                    *ptr1.add(36).cast::<f32>() = _rt::as_f32(m122);
                    *ptr1.add(40).cast::<f32>() = _rt::as_f32(m222);
                    *ptr1.add(44).cast::<f32>() = _rt::as_f32(m322);
                    *ptr1.add(48).cast::<f32>() = _rt::as_f32(m032);
                    *ptr1.add(52).cast::<f32>() = _rt::as_f32(m132);
                    *ptr1.add(56).cast::<f32>() = _rt::as_f32(m232);
                    *ptr1.add(60).cast::<f32>() = _rt::as_f32(m332);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<f32>();
                    let l1 = *arg0.add(4).cast::<f32>();
                    let l2 = *arg0.add(8).cast::<f32>();
                    let l3 = *arg0.add(12).cast::<f32>();
                    let l4 = *arg0.add(16).cast::<f32>();
                    let l5 = *arg0.add(20).cast::<f32>();
                    let l6 = *arg0.add(24).cast::<f32>();
                    let l7 = *arg0.add(28).cast::<f32>();
                    let l8 = *arg0.add(32).cast::<f32>();
                    let l9 = *arg0.add(36).cast::<f32>();
                    let l10 = *arg0.add(40).cast::<f32>();
                    let l11 = *arg0.add(44).cast::<f32>();
                    let l12 = *arg0.add(48).cast::<f32>();
                    let l13 = *arg0.add(52).cast::<f32>();
                    let l14 = *arg0.add(56).cast::<f32>();
                    let l15 = *arg0.add(60).cast::<f32>();
                    let l16 = *arg0.add(64).cast::<f32>();
                    let l17 = *arg0.add(68).cast::<f32>();
                    let l18 = *arg0.add(72).cast::<f32>();
                    let l19 = *arg0.add(76).cast::<f32>();
                    let l20 = *arg0.add(80).cast::<f32>();
                    let l21 = *arg0.add(84).cast::<f32>();
                    let l22 = *arg0.add(88).cast::<f32>();
                    let l23 = *arg0.add(92).cast::<f32>();
                    let l24 = *arg0.add(96).cast::<f32>();
                    let l25 = *arg0.add(100).cast::<f32>();
                    let l26 = *arg0.add(104).cast::<f32>();
                    let l27 = *arg0.add(108).cast::<f32>();
                    let l28 = *arg0.add(112).cast::<f32>();
                    let l29 = *arg0.add(116).cast::<f32>();
                    let l30 = *arg0.add(120).cast::<f32>();
                    let l31 = *arg0.add(124).cast::<f32>();
                    let result32 = T::mul(
                        super::super::super::super::exports::ardo314::math::types::Matrix4x4 {
                            m00: l0,
                            m10: l1,
                            m20: l2,
                            m30: l3,
                            m01: l4,
                            m11: l5,
                            m21: l6,
                            m31: l7,
                            m02: l8,
                            m12: l9,
                            m22: l10,
                            m32: l11,
                            m03: l12,
                            m13: l13,
                            m23: l14,
                            m33: l15,
                        },
                        super::super::super::super::exports::ardo314::math::types::Matrix4x4 {
                            m00: l16,
                            m10: l17,
                            m20: l18,
                            m30: l19,
                            m01: l20,
                            m11: l21,
                            m21: l22,
                            m31: l23,
                            m02: l24,
                            m12: l25,
                            m22: l26,
                            m32: l27,
                            m03: l28,
                            m13: l29,
                            m23: l30,
                            m33: l31,
                        },
                    );
                    _rt::cabi_dealloc(arg0, 128, 4);
                    let ptr33 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix4x4 {
                        m00: m0034,
                        m10: m1034,
                        m20: m2034,
                        m30: m3034,
                        m01: m0134,
                        m11: m1134,
                        m21: m2134,
                        m31: m3134,
                        m02: m0234,
                        m12: m1234,
                        m22: m2234,
                        m32: m3234,
                        m03: m0334,
                        m13: m1334,
                        m23: m2334,
                        m33: m3334,
                    } = result32;
                    *ptr33.add(0).cast::<f32>() = _rt::as_f32(m0034);
                    *ptr33.add(4).cast::<f32>() = _rt::as_f32(m1034);
                    *ptr33.add(8).cast::<f32>() = _rt::as_f32(m2034);
                    *ptr33.add(12).cast::<f32>() = _rt::as_f32(m3034);
                    *ptr33.add(16).cast::<f32>() = _rt::as_f32(m0134);
                    *ptr33.add(20).cast::<f32>() = _rt::as_f32(m1134);
                    *ptr33.add(24).cast::<f32>() = _rt::as_f32(m2134);
                    *ptr33.add(28).cast::<f32>() = _rt::as_f32(m3134);
                    *ptr33.add(32).cast::<f32>() = _rt::as_f32(m0234);
                    *ptr33.add(36).cast::<f32>() = _rt::as_f32(m1234);
                    *ptr33.add(40).cast::<f32>() = _rt::as_f32(m2234);
                    *ptr33.add(44).cast::<f32>() = _rt::as_f32(m3234);
                    *ptr33.add(48).cast::<f32>() = _rt::as_f32(m0334);
                    *ptr33.add(52).cast::<f32>() = _rt::as_f32(m1334);
                    *ptr33.add(56).cast::<f32>() = _rt::as_f32(m2334);
                    *ptr33.add(60).cast::<f32>() = _rt::as_f32(m3334);
                    ptr33
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_vector4d_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<f32>();
                    let l1 = *arg0.add(4).cast::<f32>();
                    let l2 = *arg0.add(8).cast::<f32>();
                    let l3 = *arg0.add(12).cast::<f32>();
                    let l4 = *arg0.add(16).cast::<f32>();
                    let l5 = *arg0.add(20).cast::<f32>();
                    let l6 = *arg0.add(24).cast::<f32>();
                    let l7 = *arg0.add(28).cast::<f32>();
                    let l8 = *arg0.add(32).cast::<f32>();
                    let l9 = *arg0.add(36).cast::<f32>();
                    let l10 = *arg0.add(40).cast::<f32>();
                    let l11 = *arg0.add(44).cast::<f32>();
                    let l12 = *arg0.add(48).cast::<f32>();
                    let l13 = *arg0.add(52).cast::<f32>();
                    let l14 = *arg0.add(56).cast::<f32>();
                    let l15 = *arg0.add(60).cast::<f32>();
                    let l16 = *arg0.add(64).cast::<f32>();
                    let l17 = *arg0.add(68).cast::<f32>();
                    let l18 = *arg0.add(72).cast::<f32>();
                    let l19 = *arg0.add(76).cast::<f32>();
                    let result20 = T::mul_vector4d(
                        super::super::super::super::exports::ardo314::math::types::Matrix4x4 {
                            m00: l0,
                            m10: l1,
                            m20: l2,
                            m30: l3,
                            m01: l4,
                            m11: l5,
                            m21: l6,
                            m31: l7,
                            m02: l8,
                            m12: l9,
                            m22: l10,
                            m32: l11,
                            m03: l12,
                            m13: l13,
                            m23: l14,
                            m33: l15,
                        },
                        (l16, l17, l18, l19),
                    );
                    _rt::cabi_dealloc(arg0, 80, 4);
                    let ptr21 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t22_0, t22_1, t22_2, t22_3) = result20;
                    *ptr21.add(0).cast::<f32>() = _rt::as_f32(t22_0);
                    *ptr21.add(4).cast::<f32>() = _rt::as_f32(t22_1);
                    *ptr21.add(8).cast::<f32>() = _rt::as_f32(t22_2);
                    *ptr21.add(12).cast::<f32>() = _rt::as_f32(t22_3);
                    ptr21
                }
                pub trait Guest {
                    fn identity() -> Matrix4x4;
                    fn mul(lhs: Matrix4x4, rhs: Matrix4x4) -> Matrix4x4;
                    fn mul_vector4d(lhs: Matrix4x4, rhs: Vector4d) -> Vector4d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_matrix4x4_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/matrix4x4@0.0.3#identity")] unsafe extern "C" fn
                        export_identity() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_identity_cabi::<$ty > () } } #[unsafe (export_name =
                        "ardo314:math/matrix4x4@0.0.3#mul")] unsafe extern "C" fn
                        export_mul(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_mul_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name = "ardo314:math/matrix4x4@0.0.3#mul-vector4d")]
                        unsafe extern "C" fn export_mul_vector4d(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_vector4d_cabi::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_matrix4x4_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 64]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 64],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod rotation_vector {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type RotationVector = super::super::super::super::exports::ardo314::math::types::RotationVector;
                pub type Quaternion = super::super::super::super::exports::ardo314::math::types::Quaternion;
                pub type Matrix3x3 = super::super::super::super::exports::ardo314::math::types::Matrix3x3;
                pub type AxisAngle = super::super::super::super::exports::ardo314::math::types::AxisAngle;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_identity_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::identity();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_f32((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div_f32((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_axis_angle_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_axis_angle((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    let (t3_0, t3_1, t3_2) = t2_0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t3_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t3_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t3_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_quaternion_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_quaternion((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_matrix3x3_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_matrix3x3((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                        m00: m002,
                        m10: m102,
                        m20: m202,
                        m01: m012,
                        m11: m112,
                        m21: m212,
                        m02: m022,
                        m12: m122,
                        m22: m222,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m202);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(16).cast::<f32>() = _rt::as_f32(m112);
                    *ptr1.add(20).cast::<f32>() = _rt::as_f32(m212);
                    *ptr1.add(24).cast::<f32>() = _rt::as_f32(m022);
                    *ptr1.add(28).cast::<f32>() = _rt::as_f32(m122);
                    *ptr1.add(32).cast::<f32>() = _rt::as_f32(m222);
                    ptr1
                }
                pub trait Guest {
                    fn identity() -> RotationVector;
                    fn mul_f32(rv: RotationVector, s: f32) -> RotationVector;
                    fn div_f32(rv: RotationVector, s: f32) -> RotationVector;
                    fn to_axis_angle(rv: RotationVector) -> AxisAngle;
                    fn to_quaternion(rv: RotationVector) -> Quaternion;
                    fn to_matrix3x3(rv: RotationVector) -> Matrix3x3;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_rotation_vector_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/rotation-vector@0.0.3#identity")] unsafe extern "C"
                        fn export_identity() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_identity_cabi::<$ty > () } } #[unsafe (export_name =
                        "ardo314:math/rotation-vector@0.0.3#mul-f32")] unsafe extern "C"
                        fn export_mul_f32(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_f32_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "ardo314:math/rotation-vector@0.0.3#div-f32")] unsafe extern "C"
                        fn export_div_f32(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_div_f32_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "ardo314:math/rotation-vector@0.0.3#to-axis-angle")] unsafe
                        extern "C" fn export_to_axis_angle(arg0 : f32, arg1 : f32, arg2 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_axis_angle_cabi::<$ty > (arg0, arg1, arg2) } }
                        #[unsafe (export_name =
                        "ardo314:math/rotation-vector@0.0.3#to-quaternion")] unsafe
                        extern "C" fn export_to_quaternion(arg0 : f32, arg1 : f32, arg2 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_quaternion_cabi::<$ty > (arg0, arg1, arg2) } }
                        #[unsafe (export_name =
                        "ardo314:math/rotation-vector@0.0.3#to-matrix3x3")] unsafe extern
                        "C" fn export_to_matrix3x3(arg0 : f32, arg1 : f32, arg2 : f32,)
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_matrix3x3_cabi::<$ty > (arg0, arg1, arg2) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_rotation_vector_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 36],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod axis_angle {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type AxisAngle = super::super::super::super::exports::ardo314::math::types::AxisAngle;
                pub type RotationVector = super::super::super::super::exports::ardo314::math::types::RotationVector;
                pub type Quaternion = super::super::super::super::exports::ardo314::math::types::Quaternion;
                pub type Matrix3x3 = super::super::super::super::exports::ardo314::math::types::Matrix3x3;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_identity_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::identity();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    let (t3_0, t3_1, t3_2) = t2_0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t3_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t3_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t3_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul_f32(((arg0, arg1, arg2), arg3), arg4);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    let (t3_0, t3_1, t3_2) = t2_0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t3_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t3_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t3_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_f32_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div_f32(((arg0, arg1, arg2), arg3), arg4);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    let (t3_0, t3_1, t3_2) = t2_0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t3_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t3_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t3_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_rotation_vector_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_rotation_vector(((arg0, arg1, arg2), arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_quaternion_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_quaternion(((arg0, arg1, arg2), arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_matrix3x3_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_matrix3x3(((arg0, arg1, arg2), arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                        m00: m002,
                        m10: m102,
                        m20: m202,
                        m01: m012,
                        m11: m112,
                        m21: m212,
                        m02: m022,
                        m12: m122,
                        m22: m222,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m202);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(16).cast::<f32>() = _rt::as_f32(m112);
                    *ptr1.add(20).cast::<f32>() = _rt::as_f32(m212);
                    *ptr1.add(24).cast::<f32>() = _rt::as_f32(m022);
                    *ptr1.add(28).cast::<f32>() = _rt::as_f32(m122);
                    *ptr1.add(32).cast::<f32>() = _rt::as_f32(m222);
                    ptr1
                }
                pub trait Guest {
                    fn identity() -> AxisAngle;
                    fn mul_f32(aa: AxisAngle, s: f32) -> AxisAngle;
                    fn div_f32(aa: AxisAngle, s: f32) -> AxisAngle;
                    fn to_rotation_vector(aa: AxisAngle) -> RotationVector;
                    fn to_quaternion(aa: AxisAngle) -> Quaternion;
                    fn to_matrix3x3(aa: AxisAngle) -> Matrix3x3;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_axis_angle_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/axis-angle@0.0.3#identity")] unsafe extern "C" fn
                        export_identity() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_identity_cabi::<$ty > () } } #[unsafe (export_name =
                        "ardo314:math/axis-angle@0.0.3#mul-f32")] unsafe extern "C" fn
                        export_mul_f32(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,
                        arg4 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_f32_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4) } }
                        #[unsafe (export_name = "ardo314:math/axis-angle@0.0.3#div-f32")]
                        unsafe extern "C" fn export_div_f32(arg0 : f32, arg1 : f32, arg2
                        : f32, arg3 : f32, arg4 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_div_f32_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4) } } #[unsafe (export_name =
                        "ardo314:math/axis-angle@0.0.3#to-rotation-vector")] unsafe
                        extern "C" fn export_to_rotation_vector(arg0 : f32, arg1 : f32,
                        arg2 : f32, arg3 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_to_rotation_vector_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/axis-angle@0.0.3#to-quaternion")] unsafe extern "C"
                        fn export_to_quaternion(arg0 : f32, arg1 : f32, arg2 : f32, arg3
                        : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_quaternion_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "ardo314:math/axis-angle@0.0.3#to-matrix3x3")] unsafe extern "C"
                        fn export_to_matrix3x3(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_matrix3x3_cabi::<$ty > (arg0, arg1, arg2, arg3) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_axis_angle_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 36],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod quaternion {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Quaternion = super::super::super::super::exports::ardo314::math::types::Quaternion;
                pub type RotationVector = super::super::super::super::exports::ardo314::math::types::RotationVector;
                pub type Matrix3x3 = super::super::super::super::exports::ardo314::math::types::Matrix3x3;
                pub type AxisAngle = super::super::super::super::exports::ardo314::math::types::AxisAngle;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_identity_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::identity();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2, t2_3) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_3);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_axis_angle_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_axis_angle((arg0, arg1, arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    let (t3_0, t3_1, t3_2) = t2_0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t3_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t3_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t3_2);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_rotation_vector_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_rotation_vector((arg0, arg1, arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_to_matrix3x3_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::to_matrix3x3((arg0, arg1, arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::ardo314::math::types::Matrix3x3 {
                        m00: m002,
                        m10: m102,
                        m20: m202,
                        m01: m012,
                        m11: m112,
                        m21: m212,
                        m02: m022,
                        m12: m122,
                        m22: m222,
                    } = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(m002);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(m102);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(m202);
                    *ptr1.add(12).cast::<f32>() = _rt::as_f32(m012);
                    *ptr1.add(16).cast::<f32>() = _rt::as_f32(m112);
                    *ptr1.add(20).cast::<f32>() = _rt::as_f32(m212);
                    *ptr1.add(24).cast::<f32>() = _rt::as_f32(m022);
                    *ptr1.add(28).cast::<f32>() = _rt::as_f32(m122);
                    *ptr1.add(32).cast::<f32>() = _rt::as_f32(m222);
                    ptr1
                }
                pub trait Guest {
                    fn identity() -> Quaternion;
                    fn to_axis_angle(q: Quaternion) -> AxisAngle;
                    fn to_rotation_vector(q: Quaternion) -> RotationVector;
                    fn to_matrix3x3(q: Quaternion) -> Matrix3x3;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_quaternion_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/quaternion@0.0.3#identity")] unsafe extern "C" fn
                        export_identity() -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_identity_cabi::<$ty > () } } #[unsafe (export_name =
                        "ardo314:math/quaternion@0.0.3#to-axis-angle")] unsafe extern "C"
                        fn export_to_axis_angle(arg0 : f32, arg1 : f32, arg2 : f32, arg3
                        : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_axis_angle_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "ardo314:math/quaternion@0.0.3#to-rotation-vector")] unsafe
                        extern "C" fn export_to_rotation_vector(arg0 : f32, arg1 : f32,
                        arg2 : f32, arg3 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_to_rotation_vector_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/quaternion@0.0.3#to-matrix3x3")] unsafe extern "C"
                        fn export_to_matrix3x3(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_to_matrix3x3_cabi::<$ty > (arg0, arg1, arg2, arg3) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_quaternion_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 36]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 36],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod point2d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Point2d = super::super::super::super::exports::ardo314::math::types::Point2d;
                pub type Vector2d = super::super::super::super::exports::ardo314::math::types::Vector2d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_vector2d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_vector2d((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_vector2d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_vector2d((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                pub trait Guest {
                    fn add_vector2d(p: Point2d, v: Vector2d) -> Point2d;
                    fn sub_vector2d(p: Point2d, v: Vector2d) -> Point2d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_point2d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/point2d@0.0.3#add-vector2d")] unsafe extern "C" fn
                        export_add_vector2d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_add_vector2d_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "ardo314:math/point2d@0.0.3#sub-vector2d")] unsafe extern "C" fn
                        export_sub_vector2d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_sub_vector2d_cabi::<$ty > (arg0, arg1, arg2, arg3) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_point2d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod point3d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Point3d = super::super::super::super::exports::ardo314::math::types::Point3d;
                pub type Vector3d = super::super::super::super::exports::ardo314::math::types::Vector3d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_vector3d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_vector3d(
                        (arg0, arg1, arg2),
                        (arg3, arg4, arg5),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_vector3d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_vector3d(
                        (arg0, arg1, arg2),
                        (arg3, arg4, arg5),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                pub trait Guest {
                    fn add_vector3d(p: Point3d, v: Vector3d) -> Point3d;
                    fn sub_vector3d(p: Point3d, v: Vector3d) -> Point3d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_point3d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/point3d@0.0.3#add-vector3d")] unsafe extern "C" fn
                        export_add_vector3d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_add_vector3d_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "ardo314:math/point3d@0.0.3#sub-vector3d")] unsafe extern "C" fn
                        export_sub_vector3d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sub_vector3d_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_point3d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 12],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod pose2d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Pose2d = super::super::super::super::exports::ardo314::math::types::Pose2d;
                pub type Point2d = super::super::super::super::exports::ardo314::math::types::Point2d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_position_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::position((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_rotation_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::rotation((arg0, arg1, arg2));
                    _rt::as_f32(result0)
                }
                pub trait Guest {
                    fn position(p: Pose2d) -> Point2d;
                    fn rotation(p: Pose2d) -> f32;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_pose2d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/pose2d@0.0.3#position")] unsafe extern "C" fn
                        export_position(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_position_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/pose2d@0.0.3#rotation")] unsafe extern "C" fn
                        export_rotation(arg0 : f32, arg1 : f32, arg2 : f32,) -> f32 {
                        unsafe { $($path_to_types)*:: _export_rotation_cabi::<$ty >
                        (arg0, arg1, arg2) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_pose2d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod pose3d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Pose3d = super::super::super::super::exports::ardo314::math::types::Pose3d;
                pub type Point3d = super::super::super::super::exports::ardo314::math::types::Point3d;
                pub type RotationVector = super::super::super::super::exports::ardo314::math::types::RotationVector;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_position_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::position((arg0, arg1, arg2, arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_rotation_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::rotation((arg0, arg1, arg2, arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                pub trait Guest {
                    fn position(p: Pose3d) -> Point3d;
                    fn rotation(p: Pose3d) -> RotationVector;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_pose3d_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/pose3d@0.0.3#position")] unsafe extern "C" fn
                        export_position(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,
                        arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_position_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "ardo314:math/pose3d@0.0.3#rotation")] unsafe extern "C" fn
                        export_rotation(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,
                        arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_rotation_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_pose3d_0_0_3_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 12],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod plane {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_plane_0_0_3_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_plane_0_0_3_cabi;
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_math_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::ardo314::math::types::__export_ardo314_math_types_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::types);
        $($path_to_types_root)*::
        exports::ardo314::math::vector2d::__export_ardo314_math_vector2d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::vector2d);
        $($path_to_types_root)*::
        exports::ardo314::math::vector3d::__export_ardo314_math_vector3d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::vector3d);
        $($path_to_types_root)*::
        exports::ardo314::math::vector4d::__export_ardo314_math_vector4d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::vector4d);
        $($path_to_types_root)*::
        exports::ardo314::math::matrix2x2::__export_ardo314_math_matrix2x2_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::matrix2x2);
        $($path_to_types_root)*::
        exports::ardo314::math::matrix3x3::__export_ardo314_math_matrix3x3_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::matrix3x3);
        $($path_to_types_root)*::
        exports::ardo314::math::matrix4x4::__export_ardo314_math_matrix4x4_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::matrix4x4);
        $($path_to_types_root)*::
        exports::ardo314::math::rotation_vector::__export_ardo314_math_rotation_vector_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::rotation_vector);
        $($path_to_types_root)*::
        exports::ardo314::math::axis_angle::__export_ardo314_math_axis_angle_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::axis_angle);
        $($path_to_types_root)*::
        exports::ardo314::math::quaternion::__export_ardo314_math_quaternion_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::quaternion);
        $($path_to_types_root)*::
        exports::ardo314::math::point2d::__export_ardo314_math_point2d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::point2d);
        $($path_to_types_root)*::
        exports::ardo314::math::point3d::__export_ardo314_math_point3d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::point3d);
        $($path_to_types_root)*::
        exports::ardo314::math::pose2d::__export_ardo314_math_pose2d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::pose2d);
        $($path_to_types_root)*::
        exports::ardo314::math::pose3d::__export_ardo314_math_pose3d_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::pose3d);
        $($path_to_types_root)*::
        exports::ardo314::math::plane::__export_ardo314_math_plane_0_0_3_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::plane);
    };
}
#[doc(inline)]
pub(crate) use __export_math_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:ardo314:math@0.0.3:math:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3283] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd8\x18\x01A\x02\x01\
A,\x01B\x1c\x01o\x02vv\x04\0\x08vector2d\x03\0\0\x01o\x03vvv\x04\0\x08vector3d\x03\
\0\x02\x01o\x04vvvv\x04\0\x08vector4d\x03\0\x04\x01r\x04\x03m00v\x03m10v\x03m01v\
\x03m11v\x04\0\x09matrix2x2\x03\0\x06\x01r\x09\x03m00v\x03m10v\x03m20v\x03m01v\x03\
m11v\x03m21v\x03m02v\x03m12v\x03m22v\x04\0\x09matrix3x3\x03\0\x08\x01r\x10\x03m0\
0v\x03m10v\x03m20v\x03m30v\x03m01v\x03m11v\x03m21v\x03m31v\x03m02v\x03m12v\x03m2\
2v\x03m32v\x03m03v\x03m13v\x03m23v\x03m33v\x04\0\x09matrix4x4\x03\0\x0a\x01o\x03\
vvv\x04\0\x0frotation-vector\x03\0\x0c\x01o\x02\x03v\x04\0\x0aaxis-angle\x03\0\x0e\
\x01o\x04vvvv\x04\0\x0aquaternion\x03\0\x10\x01o\x03vvv\x04\0\x06pose2d\x03\0\x12\
\x01o\x06vvvvvv\x04\0\x06pose3d\x03\0\x14\x01o\x02vv\x04\0\x07point2d\x03\0\x16\x01\
o\x03vvv\x04\0\x07point3d\x03\0\x18\x01r\x02\x06normal\x03\x01dv\x04\0\x05plane\x03\
\0\x1a\x04\0\x18ardo314:math/types@0.0.3\x05\0\x02\x03\0\0\x08vector2d\x01B\x12\x02\
\x03\x02\x01\x01\x04\0\x08vector2d\x03\0\0\x01@\x02\x03lhs\x01\x03rhs\x01\0\x01\x04\
\0\x03add\x01\x02\x04\0\x03sub\x01\x02\x01@\x02\x03lhs\x01\x03rhs\x01\0v\x04\0\x03\
dot\x01\x03\x01@\x02\x03lhs\x01\x03rhsv\0\x01\x04\0\x07add-f32\x01\x04\x04\0\x07\
sub-f32\x01\x04\x04\0\x07mul-f32\x01\x04\x04\0\x07div-f32\x01\x04\x01@\x01\x01v\x01\
\0\x01\x04\0\x03neg\x01\x05\x01@\x01\x01v\x01\0v\x04\0\x0asqr-length\x01\x06\x04\
\0\x06length\x01\x06\x04\0\x09normalize\x01\x05\x04\0\x1bardo314:math/vector2d@0\
.0.3\x05\x02\x02\x03\0\0\x08vector3d\x01B\x13\x02\x03\x02\x01\x03\x04\0\x08vecto\
r3d\x03\0\0\x01@\x02\x03lhs\x01\x03rhs\x01\0\x01\x04\0\x03add\x01\x02\x04\0\x03s\
ub\x01\x02\x01@\x02\x03lhs\x01\x03rhs\x01\0v\x04\0\x03dot\x01\x03\x01@\x02\x03lh\
s\x01\x03rhsv\0\x01\x04\0\x07add-f32\x01\x04\x04\0\x07sub-f32\x01\x04\x04\0\x07m\
ul-f32\x01\x04\x04\0\x07div-f32\x01\x04\x01@\x01\x01v\x01\0\x01\x04\0\x03neg\x01\
\x05\x01@\x01\x01v\x01\0v\x04\0\x0asqr-length\x01\x06\x04\0\x06length\x01\x06\x04\
\0\x09normalize\x01\x05\x04\0\x05cross\x01\x02\x04\0\x1bardo314:math/vector3d@0.\
0.3\x05\x04\x02\x03\0\0\x08vector4d\x01B\x12\x02\x03\x02\x01\x05\x04\0\x08vector\
4d\x03\0\0\x01@\x02\x03lhs\x01\x03rhs\x01\0\x01\x04\0\x03add\x01\x02\x04\0\x03su\
b\x01\x02\x01@\x02\x03lhs\x01\x03rhs\x01\0v\x04\0\x03dot\x01\x03\x01@\x02\x03lhs\
\x01\x03rhsv\0\x01\x04\0\x07add-f32\x01\x04\x04\0\x07sub-f32\x01\x04\x04\0\x07mu\
l-f32\x01\x04\x04\0\x07div-f32\x01\x04\x01@\x01\x01v\x01\0\x01\x04\0\x03neg\x01\x05\
\x01@\x01\x01v\x01\0v\x04\0\x0asqr-length\x01\x06\x04\0\x06length\x01\x06\x04\0\x09\
normalize\x01\x05\x04\0\x1bardo314:math/vector4d@0.0.3\x05\x06\x02\x03\0\0\x09ma\
trix2x2\x01B\x0a\x02\x03\x02\x01\x07\x04\0\x09matrix2x2\x03\0\0\x02\x03\x02\x01\x01\
\x04\0\x08vector2d\x03\0\x02\x01@\0\0\x01\x04\0\x08identity\x01\x04\x01@\x02\x03\
lhs\x01\x03rhs\x01\0\x01\x04\0\x03mul\x01\x05\x01@\x02\x03lhs\x01\x03rhs\x03\0\x03\
\x04\0\x0cmul-vector2d\x01\x06\x04\0\x1cardo314:math/matrix2x2@0.0.3\x05\x08\x02\
\x03\0\0\x09matrix3x3\x01B\x0a\x02\x03\x02\x01\x09\x04\0\x09matrix3x3\x03\0\0\x02\
\x03\x02\x01\x03\x04\0\x08vector3d\x03\0\x02\x01@\0\0\x01\x04\0\x08identity\x01\x04\
\x01@\x02\x03lhs\x01\x03rhs\x01\0\x01\x04\0\x03mul\x01\x05\x01@\x02\x03lhs\x01\x03\
rhs\x03\0\x03\x04\0\x0cmul-vector3d\x01\x06\x04\0\x1cardo314:math/matrix3x3@0.0.\
3\x05\x0a\x02\x03\0\0\x09matrix4x4\x01B\x0a\x02\x03\x02\x01\x0b\x04\0\x09matrix4\
x4\x03\0\0\x02\x03\x02\x01\x05\x04\0\x08vector4d\x03\0\x02\x01@\0\0\x01\x04\0\x08\
identity\x01\x04\x01@\x02\x03lhs\x01\x03rhs\x01\0\x01\x04\0\x03mul\x01\x05\x01@\x02\
\x03lhs\x01\x03rhs\x03\0\x03\x04\0\x0cmul-vector4d\x01\x06\x04\0\x1cardo314:math\
/matrix4x4@0.0.3\x05\x0c\x02\x03\0\0\x0frotation-vector\x02\x03\0\0\x0aquaternio\
n\x02\x03\0\0\x0aaxis-angle\x01B\x15\x02\x03\x02\x01\x0d\x04\0\x0frotation-vecto\
r\x03\0\0\x02\x03\x02\x01\x03\x04\0\x08vector3d\x03\0\x02\x02\x03\x02\x01\x0e\x04\
\0\x0aquaternion\x03\0\x04\x02\x03\x02\x01\x09\x04\0\x09matrix3x3\x03\0\x06\x02\x03\
\x02\x01\x0f\x04\0\x0aaxis-angle\x03\0\x08\x01@\0\0\x01\x04\0\x08identity\x01\x0a\
\x01@\x02\x02rv\x01\x01sv\0\x01\x04\0\x07mul-f32\x01\x0b\x04\0\x07div-f32\x01\x0b\
\x01@\x01\x02rv\x01\0\x09\x04\0\x0dto-axis-angle\x01\x0c\x01@\x01\x02rv\x01\0\x05\
\x04\0\x0dto-quaternion\x01\x0d\x01@\x01\x02rv\x01\0\x07\x04\0\x0cto-matrix3x3\x01\
\x0e\x04\0\"ardo314:math/rotation-vector@0.0.3\x05\x10\x01B\x13\x02\x03\x02\x01\x0f\
\x04\0\x0aaxis-angle\x03\0\0\x02\x03\x02\x01\x0d\x04\0\x0frotation-vector\x03\0\x02\
\x02\x03\x02\x01\x0e\x04\0\x0aquaternion\x03\0\x04\x02\x03\x02\x01\x09\x04\0\x09\
matrix3x3\x03\0\x06\x01@\0\0\x01\x04\0\x08identity\x01\x08\x01@\x02\x02aa\x01\x01\
sv\0\x01\x04\0\x07mul-f32\x01\x09\x04\0\x07div-f32\x01\x09\x01@\x01\x02aa\x01\0\x03\
\x04\0\x12to-rotation-vector\x01\x0a\x01@\x01\x02aa\x01\0\x05\x04\0\x0dto-quater\
nion\x01\x0b\x01@\x01\x02aa\x01\0\x07\x04\0\x0cto-matrix3x3\x01\x0c\x04\0\x1dard\
o314:math/axis-angle@0.0.3\x05\x11\x01B\x12\x02\x03\x02\x01\x0e\x04\0\x0aquatern\
ion\x03\0\0\x02\x03\x02\x01\x0d\x04\0\x0frotation-vector\x03\0\x02\x02\x03\x02\x01\
\x03\x04\0\x08vector3d\x03\0\x04\x02\x03\x02\x01\x09\x04\0\x09matrix3x3\x03\0\x06\
\x02\x03\x02\x01\x0f\x04\0\x0aaxis-angle\x03\0\x08\x01@\0\0\x01\x04\0\x08identit\
y\x01\x0a\x01@\x01\x01q\x01\0\x09\x04\0\x0dto-axis-angle\x01\x0b\x01@\x01\x01q\x01\
\0\x03\x04\0\x12to-rotation-vector\x01\x0c\x01@\x01\x01q\x01\0\x07\x04\0\x0cto-m\
atrix3x3\x01\x0d\x04\0\x1dardo314:math/quaternion@0.0.3\x05\x12\x02\x03\0\0\x07p\
oint2d\x01B\x07\x02\x03\x02\x01\x13\x04\0\x07point2d\x03\0\0\x02\x03\x02\x01\x01\
\x04\0\x08vector2d\x03\0\x02\x01@\x02\x01p\x01\x01v\x03\0\x01\x04\0\x0cadd-vecto\
r2d\x01\x04\x04\0\x0csub-vector2d\x01\x04\x04\0\x1aardo314:math/point2d@0.0.3\x05\
\x14\x02\x03\0\0\x07point3d\x01B\x07\x02\x03\x02\x01\x15\x04\0\x07point3d\x03\0\0\
\x02\x03\x02\x01\x03\x04\0\x08vector3d\x03\0\x02\x01@\x02\x01p\x01\x01v\x03\0\x01\
\x04\0\x0cadd-vector3d\x01\x04\x04\0\x0csub-vector3d\x01\x04\x04\0\x1aardo314:ma\
th/point3d@0.0.3\x05\x16\x02\x03\0\0\x06pose2d\x01B\x08\x02\x03\x02\x01\x17\x04\0\
\x06pose2d\x03\0\0\x02\x03\x02\x01\x13\x04\0\x07point2d\x03\0\x02\x01@\x01\x01p\x01\
\0\x03\x04\0\x08position\x01\x04\x01@\x01\x01p\x01\0v\x04\0\x08rotation\x01\x05\x04\
\0\x19ardo314:math/pose2d@0.0.3\x05\x18\x02\x03\0\0\x06pose3d\x01B\x0a\x02\x03\x02\
\x01\x19\x04\0\x06pose3d\x03\0\0\x02\x03\x02\x01\x15\x04\0\x07point3d\x03\0\x02\x02\
\x03\x02\x01\x0d\x04\0\x0frotation-vector\x03\0\x04\x01@\x01\x01p\x01\0\x03\x04\0\
\x08position\x01\x06\x01@\x01\x01p\x01\0\x05\x04\0\x08rotation\x01\x07\x04\0\x19\
ardo314:math/pose3d@0.0.3\x05\x1a\x02\x03\0\0\x05plane\x01B\x02\x02\x03\x02\x01\x1b\
\x04\0\x05plane\x03\0\0\x04\0\x18ardo314:math/plane@0.0.3\x05\x1c\x04\0\x17ardo3\
14:math/math@0.0.3\x04\0\x0b\x0a\x01\0\x04math\x03\0\0\0G\x09producers\x01\x0cpr\
ocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}

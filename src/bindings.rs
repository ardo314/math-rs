// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod ardo314 {
        pub mod math {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                pub type Vector2d = (f32, f32);
                /// x, y
                pub type Vector3d = (f32, f32, f32);
                /// x, y, z, w
                pub type Point2d = (f32, f32);
                /// x, y
                pub type Point3d = (f32, f32, f32);
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_types_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_types_0_0_1_cabi;
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vector2d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Vector2d = super::super::super::super::exports::ardo314::math::types::Vector2d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_dot_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::dot((arg0, arg1), (arg2, arg3));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul((arg0, arg1), arg2);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div((arg0, arg1), arg2);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_neg_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::neg((arg0, arg1));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sqr_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sqr_length((arg0, arg1));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::length((arg0, arg1));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_normalize_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::normalize((arg0, arg1));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                pub trait Guest {
                    fn add(lhs: Vector2d, rhs: Vector2d) -> Vector2d;
                    fn sub(lhs: Vector2d, rhs: Vector2d) -> Vector2d;
                    fn dot(lhs: Vector2d, rhs: Vector2d) -> f32;
                    fn mul(lhs: Vector2d, rhs: f32) -> Vector2d;
                    fn div(lhs: Vector2d, rhs: f32) -> Vector2d;
                    fn neg(v: Vector2d) -> Vector2d;
                    fn sqr_length(v: Vector2d) -> f32;
                    fn length(v: Vector2d) -> f32;
                    fn normalize(v: Vector2d) -> Vector2d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_vector2d_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#add")] unsafe extern "C" fn
                        export_add(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) -> *
                        mut u8 { unsafe { $($path_to_types)*:: _export_add_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#sub")] unsafe extern "C" fn
                        export_sub(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) -> *
                        mut u8 { unsafe { $($path_to_types)*:: _export_sub_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#dot")] unsafe extern "C" fn
                        export_dot(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32,) ->
                        f32 { unsafe { $($path_to_types)*:: _export_dot_cabi::<$ty >
                        (arg0, arg1, arg2, arg3) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#mul")] unsafe extern "C" fn
                        export_mul(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_mul_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#div")] unsafe extern "C" fn
                        export_div(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_div_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#neg")] unsafe extern "C" fn
                        export_neg(arg0 : f32, arg1 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_neg_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#sqr-length")] unsafe extern "C" fn
                        export_sqr_length(arg0 : f32, arg1 : f32,) -> f32 { unsafe {
                        $($path_to_types)*:: _export_sqr_length_cabi::<$ty > (arg0, arg1)
                        } } #[unsafe (export_name =
                        "ardo314:math/vector2d@0.0.1#length")] unsafe extern "C" fn
                        export_length(arg0 : f32, arg1 : f32,) -> f32 { unsafe {
                        $($path_to_types)*:: _export_length_cabi::<$ty > (arg0, arg1) } }
                        #[unsafe (export_name = "ardo314:math/vector2d@0.0.1#normalize")]
                        unsafe extern "C" fn export_normalize(arg0 : f32, arg1 : f32,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_normalize_cabi::<$ty > (arg0, arg1) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_vector2d_0_0_1_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod vector3d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Vector3d = super::super::super::super::exports::ardo314::math::types::Vector3d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add((arg0, arg1, arg2), (arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub((arg0, arg1, arg2), (arg3, arg4, arg5));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_dot_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::dot((arg0, arg1, arg2), (arg3, arg4, arg5));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_mul_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::mul((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_div_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::div((arg0, arg1, arg2), arg3);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_neg_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::neg((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sqr_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sqr_length((arg0, arg1, arg2));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_length_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::length((arg0, arg1, arg2));
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_normalize_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::normalize((arg0, arg1, arg2));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                pub trait Guest {
                    fn add(lhs: Vector3d, rhs: Vector3d) -> Vector3d;
                    fn sub(lhs: Vector3d, rhs: Vector3d) -> Vector3d;
                    fn dot(lhs: Vector3d, rhs: Vector3d) -> f32;
                    fn mul(lhs: Vector3d, rhs: f32) -> Vector3d;
                    fn div(lhs: Vector3d, rhs: f32) -> Vector3d;
                    fn neg(v: Vector3d) -> Vector3d;
                    fn sqr_length(v: Vector3d) -> f32;
                    fn length(v: Vector3d) -> f32;
                    fn normalize(v: Vector3d) -> Vector3d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_vector3d_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.1#add")] unsafe extern "C" fn
                        export_add(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_add_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.1#sub")]
                        unsafe extern "C" fn export_sub(arg0 : f32, arg1 : f32, arg2 :
                        f32, arg3 : f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sub_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.1#dot")] unsafe extern "C" fn
                        export_dot(arg0 : f32, arg1 : f32, arg2 : f32, arg3 : f32, arg4 :
                        f32, arg5 : f32,) -> f32 { unsafe { $($path_to_types)*::
                        _export_dot_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5) } }
                        #[unsafe (export_name = "ardo314:math/vector3d@0.0.1#mul")]
                        unsafe extern "C" fn export_mul(arg0 : f32, arg1 : f32, arg2 :
                        f32, arg3 : f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_mul_cabi::<$ty > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name = "ardo314:math/vector3d@0.0.1#div")] unsafe extern
                        "C" fn export_div(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_div_cabi::<$ty > (arg0, arg1, arg2, arg3) } } #[unsafe
                        (export_name = "ardo314:math/vector3d@0.0.1#neg")] unsafe extern
                        "C" fn export_neg(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut
                        u8 { unsafe { $($path_to_types)*:: _export_neg_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.1#sqr-length")] unsafe extern "C" fn
                        export_sqr_length(arg0 : f32, arg1 : f32, arg2 : f32,) -> f32 {
                        unsafe { $($path_to_types)*:: _export_sqr_length_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.1#length")] unsafe extern "C" fn
                        export_length(arg0 : f32, arg1 : f32, arg2 : f32,) -> f32 {
                        unsafe { $($path_to_types)*:: _export_length_cabi::<$ty > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "ardo314:math/vector3d@0.0.1#normalize")] unsafe extern "C" fn
                        export_normalize(arg0 : f32, arg1 : f32, arg2 : f32,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_normalize_cabi::<$ty >
                        (arg0, arg1, arg2) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_vector3d_0_0_1_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 12],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod point2d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Point2d = super::super::super::super::exports::ardo314::math::types::Point2d;
                pub type Vector2d = super::super::super::super::exports::ardo314::math::types::Vector2d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_vector2d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_vector2d((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_vector2d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_vector2d((arg0, arg1), (arg2, arg3));
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    ptr1
                }
                pub trait Guest {
                    fn add_vector2d(p: Point2d, v: Vector2d) -> Point2d;
                    fn sub_vector2d(p: Point2d, v: Vector2d) -> Point2d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_point2d_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/point2d@0.0.1#add-vector2d")] unsafe extern "C" fn
                        export_add_vector2d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_add_vector2d_cabi::<$ty > (arg0, arg1, arg2, arg3) } }
                        #[unsafe (export_name =
                        "ardo314:math/point2d@0.0.1#sub-vector2d")] unsafe extern "C" fn
                        export_sub_vector2d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_sub_vector2d_cabi::<$ty > (arg0, arg1, arg2, arg3) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_point2d_0_0_1_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8],
                );
            }
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod point3d {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Point3d = super::super::super::super::exports::ardo314::math::types::Point3d;
                pub type Vector3d = super::super::super::super::exports::ardo314::math::types::Vector3d;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_vector3d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_vector3d(
                        (arg0, arg1, arg2),
                        (arg3, arg4, arg5),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_sub_vector3d_cabi<T: Guest>(
                    arg0: f32,
                    arg1: f32,
                    arg2: f32,
                    arg3: f32,
                    arg4: f32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::sub_vector3d(
                        (arg0, arg1, arg2),
                        (arg3, arg4, arg5),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let (t2_0, t2_1, t2_2) = result0;
                    *ptr1.add(0).cast::<f32>() = _rt::as_f32(t2_0);
                    *ptr1.add(4).cast::<f32>() = _rt::as_f32(t2_1);
                    *ptr1.add(8).cast::<f32>() = _rt::as_f32(t2_2);
                    ptr1
                }
                pub trait Guest {
                    fn add_vector3d(p: Point3d, v: Vector3d) -> Point3d;
                    fn sub_vector3d(p: Point3d, v: Vector3d) -> Point3d;
                }
                #[doc(hidden)]
                macro_rules! __export_ardo314_math_point3d_0_0_1_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ardo314:math/point3d@0.0.1#add-vector3d")] unsafe extern "C" fn
                        export_add_vector3d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_add_vector3d_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "ardo314:math/point3d@0.0.1#sub-vector3d")] unsafe extern "C" fn
                        export_sub_vector3d(arg0 : f32, arg1 : f32, arg2 : f32, arg3 :
                        f32, arg4 : f32, arg5 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_sub_vector3d_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ardo314_math_point3d_0_0_1_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 12],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_math_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::ardo314::math::types::__export_ardo314_math_types_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::types);
        $($path_to_types_root)*::
        exports::ardo314::math::vector2d::__export_ardo314_math_vector2d_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::vector2d);
        $($path_to_types_root)*::
        exports::ardo314::math::vector3d::__export_ardo314_math_vector3d_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::vector3d);
        $($path_to_types_root)*::
        exports::ardo314::math::point2d::__export_ardo314_math_point2d_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::point2d);
        $($path_to_types_root)*::
        exports::ardo314::math::point3d::__export_ardo314_math_point3d_0_0_1_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ardo314::math::point3d);
    };
}
#[doc(inline)]
pub(crate) use __export_math_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:ardo314:math@0.0.1:math:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1088] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc5\x07\x01A\x02\x01\
A\x0e\x01B\x14\x01o\x02vv\x04\0\x08vector2d\x03\0\0\x01o\x03vvv\x04\0\x08vector3\
d\x03\0\x02\x01o\x04vvvv\x04\0\x08vector4d\x03\0\x04\x01o\x03vvv\x04\0\x0frotati\
on-vector\x03\0\x06\x01o\x04vvvv\x04\0\x0aquaternion\x03\0\x08\x01o\x02vv\x04\0\x07\
point2d\x03\0\x0a\x01o\x03vvv\x04\0\x07point3d\x03\0\x0c\x01o\x03vvv\x04\0\x06po\
se2d\x03\0\x0e\x01o\x06vvvvvv\x04\0\x06pose3d\x03\0\x10\x01r\x02\x06normal\x03\x01\
dv\x04\0\x05plane\x03\0\x12\x04\0\x18ardo314:math/types@0.0.1\x05\0\x02\x03\0\0\x08\
vector2d\x01B\x10\x02\x03\x02\x01\x01\x04\0\x08vector2d\x03\0\0\x01@\x02\x03lhs\x01\
\x03rhs\x01\0\x01\x04\0\x03add\x01\x02\x04\0\x03sub\x01\x02\x01@\x02\x03lhs\x01\x03\
rhs\x01\0v\x04\0\x03dot\x01\x03\x01@\x02\x03lhs\x01\x03rhsv\0\x01\x04\0\x03mul\x01\
\x04\x04\0\x03div\x01\x04\x01@\x01\x01v\x01\0\x01\x04\0\x03neg\x01\x05\x01@\x01\x01\
v\x01\0v\x04\0\x0asqr-length\x01\x06\x04\0\x06length\x01\x06\x04\0\x09normalize\x01\
\x05\x04\0\x1bardo314:math/vector2d@0.0.1\x05\x02\x02\x03\0\0\x08vector3d\x01B\x10\
\x02\x03\x02\x01\x03\x04\0\x08vector3d\x03\0\0\x01@\x02\x03lhs\x01\x03rhs\x01\0\x01\
\x04\0\x03add\x01\x02\x04\0\x03sub\x01\x02\x01@\x02\x03lhs\x01\x03rhs\x01\0v\x04\
\0\x03dot\x01\x03\x01@\x02\x03lhs\x01\x03rhsv\0\x01\x04\0\x03mul\x01\x04\x04\0\x03\
div\x01\x04\x01@\x01\x01v\x01\0\x01\x04\0\x03neg\x01\x05\x01@\x01\x01v\x01\0v\x04\
\0\x0asqr-length\x01\x06\x04\0\x06length\x01\x06\x04\0\x09normalize\x01\x05\x04\0\
\x1bardo314:math/vector3d@0.0.1\x05\x04\x02\x03\0\0\x07point2d\x01B\x07\x02\x03\x02\
\x01\x05\x04\0\x07point2d\x03\0\0\x02\x03\x02\x01\x01\x04\0\x08vector2d\x03\0\x02\
\x01@\x02\x01p\x01\x01v\x03\0\x01\x04\0\x0cadd-vector2d\x01\x04\x04\0\x0csub-vec\
tor2d\x01\x04\x04\0\x1aardo314:math/point2d@0.0.1\x05\x06\x02\x03\0\0\x07point3d\
\x01B\x07\x02\x03\x02\x01\x07\x04\0\x07point3d\x03\0\0\x02\x03\x02\x01\x03\x04\0\
\x08vector3d\x03\0\x02\x01@\x02\x01p\x01\x01v\x03\0\x01\x04\0\x0cadd-vector3d\x01\
\x04\x04\0\x0csub-vector3d\x01\x04\x04\0\x1aardo314:math/point3d@0.0.1\x05\x08\x04\
\0\x17ardo314:math/math@0.0.1\x04\0\x0b\x0a\x01\0\x04math\x03\0\0\0G\x09producer\
s\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.4\
1.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
